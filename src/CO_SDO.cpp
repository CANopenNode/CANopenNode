/*
 * CO_SDO.cpp
 *
 *  Created on: 7 Sep 2016 Ð³.
 *      Author: a.smirnov
 *
 *      CANOpen SDO server
 *      Block transfer NOT implemented !
 */

/** Includes *****************************************************************/
#include "config.h"
#include "main.h"

#include "CO_OD.h"
#include "CO_SDO.h"

#ifdef OD_OSCommand
#include "CO_os_command_1023.h"
#endif

#include "task.h"

// generate error, if features are not correctly configured for this project
#if CO_NO_SDO_SERVER != 1
#error Features from CO_OD.h file are not correctly configured for this project!
#endif

/** Defines and constants ****************************************************/
/** Private function prototypes **********************************************/

/**
 * Function for accessing _Pre-Defined Error Field_ (index 0x1003) from SDO server.
 */
static CO_SDO_abortCode_t CO_ODF_1003(CO_ODF_arg_t *ODF_arg);

/**
 * Function for accessing _COB ID EMCY_ (index 0x1014) from SDO server.
 */
static CO_SDO_abortCode_t CO_ODF_1014(CO_ODF_arg_t *ODF_arg);

/**
 * Function for accessing _SDO server parameter_ for default SDO (index 0x1200)
 * from SDO server.
 */
static CO_SDO_abortCode_t CO_ODF_1200(CO_ODF_arg_t *ODF_arg);

/**
 * Function for accessing _PDO communication parameter_ (index 0x1400-0x1403, 0x1800-0x1803) from SDO server.
 */
static CO_SDO_abortCode_t CO_ODF_PDOcom(CO_ODF_arg_t *ODF_arg);

/** Private typedef, enumeration, class **************************************/

/**
 * Internal states of the SDO server state machine
 */
typedef enum {
    CO_SDO_ST_IDLE                  = 0x00,
    CO_SDO_ST_DOWNLOAD_INITIATE     = 0x11,
    CO_SDO_ST_DOWNLOAD_SEGMENTED    = 0x12,
    CO_SDO_ST_UPLOAD_INITIATE       = 0x21,
    CO_SDO_ST_UPLOAD_SEGMENTED      = 0x22,
} CO_SDO_state_t;


/**
 * Structure is used as array inside CO_SDO, parallel to @ref CO_SDO_objectDictionary.
 *
 * Object is generated by function CO_OD_configure(). It is then used as
 * extension to Object dictionary entry at specific index.
 */
typedef struct  {
    /** Pointer to @ref CO_SDO_OD_function */
    CO_SDO_abortCode_t (*pODFunc)(CO_ODF_arg_t *ODF_arg);
    /** Pointer to object, which will be passed to @ref CO_SDO_OD_function */
    void*               object;
} CO_OD_extension_t;


/**
 * SDO server object
 */
class cCO_SDOtransfer   {
public:

  /**
   *  @brief  Init function
   *  @param  pCO_OD                              Pointer to Object Dictionary array
   *  @param  pCO_ODExtensions                    Pointer to Object Dictionary Extensions array
   *  @param  pODInterface                        Pointer to Object Dictionary interface object
   *  @param  pCO_Driver                          Pointer to cCO_Driver
   *  @param  pUserInterface                      Pointer to cUserInterface
   */
  void vCO_SDO_Init(CO_OD_entry_t const * const   pCO_OD,
      CO_OD_extension_t const * const             pCO_ODExtensions,
      cCO_OD_Interface const * const              pODInterface,
      cCO_Driver const * const                    pCO_Driver,
      cUserInterface const * const                pUserInterface);

  /**
   * Configure additional functionality to one @ref CO_SDO_objectDictionary entry.
   *
   * Additional functionality include: @ref CO_SDO_OD_function
   * It is optional feature and can be used on any object in
   * Object dictionary. If OD entry does not exist, function returns silently.
   *
   * @param index Index of object in the Object dictionary.
   * @param pODFunc Pointer to @ref CO_SDO_OD_function, specified by application.
   * If NULL, @ref CO_SDO_OD_function will not be used on this object.
   * @param object Pointer to object, which will be passed to @ref CO_SDO_OD_function.
   */
  void          vCO_OD_Configure(uint16_t index, CO_SDO_abortCode_t (*pODFunc)(CO_ODF_arg_t *ODF_arg), void* object);

  /**
   *  @brief    Method writes CANrxData array and CANrxNew variable
   *  @param    CO_CanMsg                   Received SDO message
   *  @return   nothing
   */
  void          vSetCANrxData(const sCANMsg CO_CanMsg);

  /**
   * Process SDO communication
   *
   * @param state                           CANOpen state from @ref CO_NMT_internalState_t
   *
   * @return 0: No errors
   * @return -1: CAN driver queue full, message was not sent
   */
  int8_t        nSDO_Process(const CO_NMT_internalState_t nStateSelf);

private:

  /**
   * Abort coomunication end send respective CANOpen message
   *
   * @param code                           Abort code from @ref CO_SDO_abortCode_t
   * @return   true if success, false if CAN Send queue in driver task is full
   */
  bool          vCO_SDO_abort(uint32_t code);

  /**
   * Initialize SDO transfer.
   *
   * Find object in OD, verify, fill ODF_arg s.
   *
   * @param index Index of the object in Object dictionary.
   * @param subIndex subIndex of the object in Object dictionary.
   *
   * @return 0 on success, otherwise #CO_SDO_abortCode_t.
   */
  uint32_t      nCO_SDO_InitTransfer(uint16_t index, uint8_t subIndex);

  /**
   * Read data from @ref CO_SDO_objectDictionary to internal buffer.
   *
   * ODF_arg s must be initialized before with CO_SDO_initTransfer().
   * @ref CO_SDO_OD_function is called if configured.
   *
   * @param SDOBufferSize Total size of the SDO buffer.
   *
   * @return 0 on success, otherwise #CO_SDO_abortCode_t.
   */
  uint32_t      vCO_SDO_readOD(uint16_t SDOBufferSize);

  /**
   * Write data from internal buffer to @ref CO_SDO_objectDictionary.
   *
   * ODF_arg s must be initialized before with CO_SDO_initTransfer().
   * @ref CO_SDO_OD_function is called if configured.
   *
   * @param length Length of data (received from network) to write.
   *
   * @return 0 on success, otherwise #CO_SDO_abortCode_t.
   */
  uint32_t      vCO_SDO_writeOD(uint16_t length);

  const CO_OD_entry_t*  m_pOD;                                    /**< Pointer to the @ref CO_SDO_objectDictionary (array) */

  /**< Pointer to array of CO_OD_extension_t objects. Size of the array is equal to ODSize */
  CO_OD_extension_t*    m_pODExtensions;

  cCO_OD_Interface*     m_pODInterface;               /**< Pointer to the @ref cCO_OD_Interface object */

  cCO_Driver*           m_pCO_Driver;                 /**< Pointer to cCO_Driver */

  cUserInterface*       m_pUser;                      /**< Pointer to main User object */

  uint8_t               m_aCANrxData[8];                          /**< 8 data bytes of the received message. */

  uint8_t               m_aDataBuffer[CO_SDO_BUFFER_SIZE];        /**< SDO data buffer of size #CO_SDO_BUFFER_SIZE. */

  uint16_t              m_nODSize;                                /**< Size of the @ref CO_SDO_objectDictionary */

  uint16_t              m_nBufferOffset;                          /**< Offset in buffer of next data segment being read/written */

  uint16_t              m_nEntryNo;                               /**< Sequence number of OD entry as returned from CO_OD_find() */

  /**< CO_ODF_arg_t object with additional variables. Reference to this object is passed to @ref CO_SDO_OD_function */
  CO_ODF_arg_t          m_xODF_arg;

  uint8_t               m_nNodeId;

  /** Current internal state of the SDO server state machine #CO_SDO_state_t */
  CO_SDO_state_t        m_nState;

  /** Toggle bit in segmented transfer or block sequence in block transfer */
  uint8_t               m_nSequence;

  /** Variable indicates, if new SDO message received from CAN bus */
  bool                  m_bCANrxNew;
};//cCO_SDOtransfer -----------------------------------------------------------

/** Private functions ********************************************************/

static CO_SDO_abortCode_t CO_ODF_1003(CO_ODF_arg_t *ODF_arg) {

  uint8_t value;
  uint8_t noOfErrors = OD_preDefinedErrorField[0];
  CO_SDO_abortCode_t ret = CO_SDO_AB_NONE;

  //emPr = (CO_EMpr_t*) ODF_arg->object;
  value = ODF_arg->data[0];

  if (ODF_arg->reading) {
    if (ODF_arg->subIndex == 0) {
      ODF_arg->data[0] = noOfErrors;
    } else if (ODF_arg->subIndex > noOfErrors) {
      ret = CO_SDO_AB_NO_DATA;
    } else {
      ret = CO_SDO_AB_NONE;
    }
  } else {
    /* only '0' may be written to subIndex 0 */
    if (ODF_arg->subIndex == 0) {
      if (value == 0) {
        OD_preDefinedErrorField[0] = 0;
      } else {
        ret = CO_SDO_AB_INVALID_VALUE;
      }
    } else {
      ret = CO_SDO_AB_READONLY;
    }
  }
  return ret;
}//CO_ODF_1003 ----------------------------------------------------------------

static CO_SDO_abortCode_t CO_ODF_1014(CO_ODF_arg_t *ODF_arg) {
  uint8_t *nodeId;
  uint32_t value;
  CO_SDO_abortCode_t ret = CO_SDO_AB_NONE;

  nodeId = (uint8_t*) ODF_arg->object;
  value = CO_getUint32(ODF_arg->data);

  /* add nodeId to the value */
  if (ODF_arg->reading) {
    CO_setUint32(ODF_arg->data, value + *nodeId);
  }

  return ret;
}//CO_ODF_1014 ----------------------------------------------------------------

static CO_SDO_abortCode_t CO_ODF_1200(CO_ODF_arg_t *ODF_arg) {
  uint8_t *nodeId;
  uint32_t value;
  CO_SDO_abortCode_t ret = CO_SDO_AB_NONE;

  nodeId = (uint8_t*) ODF_arg->object;
  value = CO_getUint32(ODF_arg->data);

  /* if SDO reading Object dictionary 0x1200, add nodeId to the value */
  if ((ODF_arg->reading) && (ODF_arg->subIndex > 0)) {
    CO_setUint32(ODF_arg->data, value + *nodeId);
  }

  return ret;
}//CO_ODF_1200 ----------------------------------------------------------------

static CO_SDO_abortCode_t CO_ODF_PDOcom(CO_ODF_arg_t *ODF_arg) {
  uint8_t *nodeId;
  uint32_t value;
  CO_SDO_abortCode_t ret = CO_SDO_AB_NONE;

  nodeId = (uint8_t*) ODF_arg->object;
  value = CO_getUint32(ODF_arg->data);

  /* if SDO reading Object dictionary 0x1200, add nodeId to the value */
  if ((ODF_arg->reading) && (ODF_arg->subIndex == 1)) {
    CO_setUint32(ODF_arg->data, value + *nodeId);
  }

  return ret;
}//CO_ODF_PDOcom --------------------------------------------------------------

/** Variables and objects ****************************************************/

CO_OD_extension_t           CO_SDO_ODExtensions[CO_OD_NoOfElements];     // ODExtensions array
cCO_SDOserver               oCO_SDOserver;
cCO_SDOtransfer             oSDOtransfer;

/** Class methods ************************************************************/

void cCO_SDOtransfer::vCO_SDO_Init(CO_OD_entry_t const * const   pCO_OD,
    CO_OD_extension_t const * const             pCO_ODExtensions,
    cCO_OD_Interface const * const              pODInterface,
    cCO_Driver const * const                    pCO_Driver,
    cUserInterface const * const                pUserInterface)  {

  m_pOD               = pCO_OD;
  m_pODExtensions     = (CO_OD_extension_t*) pCO_ODExtensions;
  m_pODInterface      = (cCO_OD_Interface*) pODInterface;
  m_pCO_Driver        = (cCO_Driver*) pCO_Driver;
  m_pUser             = (cUserInterface*) pUserInterface;
  m_nODSize           = CO_OD_NoOfElements;
  m_nState            = CO_SDO_ST_IDLE;
  m_bCANrxNew         = false;
  m_nNodeId           = OD_CANNodeID;
  return;
}//cCO_SDOtransfer::vCO_SDO_Init ----------------------------------------------

void cCO_SDOtransfer::vCO_OD_Configure(uint16_t index,
                                CO_SDO_abortCode_t (*pODFunc)(CO_ODF_arg_t *ODF_arg),
                                void* object)   {
  uint16_t entryNo;

  entryNo = m_pODInterface->nCO_OD_Find(index);
  if(entryNo < 0xFFFF)  {
    CO_OD_extension_t* ext = &m_pODExtensions[entryNo];

    ext->pODFunc = pODFunc;
    ext->object = object;
  }
  return;
}//cCO_SDOtransfer::vCO_OD_Configure ------------------------------------------

void cCO_SDOtransfer::vSetCANrxData(const sCANMsg CO_CanMsg)   {
  if (CO_CanMsg.m_nDLC == 8) {
    m_aCANrxData[0] = CO_CanMsg.m_aData[0];
    m_aCANrxData[1] = CO_CanMsg.m_aData[1];
    m_aCANrxData[2] = CO_CanMsg.m_aData[2];
    m_aCANrxData[3] = CO_CanMsg.m_aData[3];
    m_aCANrxData[4] = CO_CanMsg.m_aData[4];
    m_aCANrxData[5] = CO_CanMsg.m_aData[5];
    m_aCANrxData[6] = CO_CanMsg.m_aData[6];
    m_aCANrxData[7] = CO_CanMsg.m_aData[7];
    m_bCANrxNew     = true;
  }
  return;
}//cCO_SDOtransfer::vSetCANrxData ---------------------------------------------

int8_t cCO_SDOtransfer::nSDO_Process(CO_NMT_internalState_t nStateSelf)  {

  sCANMsg CO_CanMsg;
  CO_SDO_state_t state = CO_SDO_ST_IDLE;

  CO_CanMsg.m_nDLC = 8;
  CO_CanMsg.m_nStdId = OD_SDOServerParameter[0].COB_IDServerToClient + m_nNodeId;

  // return if idle
  if ((m_nState == CO_SDO_ST_IDLE) && (!m_bCANrxNew)) {
    return 0;
  }

  // SDO is allowed to work only in operational or pre-operational NMT state
  if (((nStateSelf != CO_NMT_OPERATIONAL) && (nStateSelf != CO_NMT_PRE_OPERATIONAL))) {
    m_nState = CO_SDO_ST_IDLE;
    m_bCANrxNew = false;
    return 0;
  }

  if (m_bCANrxNew) {
    uint8_t CCS = m_aCANrxData[0] >> 5;         // Client command specifier

    // clear response buffer
    CO_CanMsg.m_aData[0] = 0;
    CO_CanMsg.m_aData[1] = 0;
    CO_CanMsg.m_aData[2] = 0;
    CO_CanMsg.m_aData[3] = 0;
    CO_CanMsg.m_aData[4] = 0;
    CO_CanMsg.m_aData[5] = 0;
    CO_CanMsg.m_aData[6] = 0;
    CO_CanMsg.m_aData[7] = 0;

    // Is abort from client?
    if (m_aCANrxData[0] == CCS_ABORT) {
      m_nState = CO_SDO_ST_IDLE;
      m_bCANrxNew = false;
      return 0;
    }

    // continue with previous SDO communication or start new
    if (m_nState != CO_SDO_ST_IDLE) {
      state = m_nState;
    } else {
      uint32_t abortCode;
      uint16_t index;

      // Is client command specifier valid
      if ((CCS != CCS_DOWNLOAD_INITIATE) && (CCS != CCS_UPLOAD_INITIATE)) {
        vCO_SDO_abort(CO_SDO_AB_CMD);
        return 0;
      }

      // init ODF_arg
      index = m_aCANrxData[2];
      index = index << 8 | m_aCANrxData[1];
      abortCode = nCO_SDO_InitTransfer(index, m_aCANrxData[3]);
      if (abortCode != 0) {
        vCO_SDO_abort(abortCode);
        return 0;
      }

      // download
      if (CCS == CCS_DOWNLOAD_INITIATE) {
        if ((m_xODF_arg.attribute & CO_ODA_WRITEABLE) == 0) {
          vCO_SDO_abort(CO_SDO_AB_READONLY);
          return 0;
        }
        state = CO_SDO_ST_DOWNLOAD_INITIATE;
      }
      // upload
      else {
        if ((m_xODF_arg.attribute & CO_ODA_READABLE) == 0)  {
          vCO_SDO_abort(CO_SDO_AB_WRITEONLY);
          return 0;
        }
        abortCode = vCO_SDO_readOD(CO_SDO_BUFFER_SIZE);
        if (abortCode != 0) {
          vCO_SDO_abort(abortCode);
          return 0;
        }
        state = CO_SDO_ST_UPLOAD_INITIATE;
      }//else (CCS == CCS_DOWNLOAD_INITIATE)
    }//else (SDO->state != CO_SDO_ST_IDLE)
  }//if (m_bCANrxNew)

  // return immediately if still idle
  if (state == CO_SDO_ST_IDLE) {
    return 0;
  }

  // state machine (buffer is freed (m_bCANrxNew = false) at the end)
  switch (state) {
  uint32_t abortCode;
  uint16_t len, i;

  case CO_SDO_ST_DOWNLOAD_INITIATE:
    // default response
    CO_CanMsg.m_aData[0] = 0x60;
    CO_CanMsg.m_aData[1] = m_aCANrxData[1];
    CO_CanMsg.m_aData[2] = m_aCANrxData[2];
    CO_CanMsg.m_aData[3] = m_aCANrxData[3];

    // Expedited transfer
    if ((m_aCANrxData[0] & 0x02) != 0) {
      // is size indicated? Get message length
      if ((m_aCANrxData[0] & 0x01) != 0) {
        len = 4 - ((m_aCANrxData[0] >> 2) & 0x03);
      } else {
        len = m_xODF_arg.dataLength;
      }

      // copy data to SDO buffer
      m_xODF_arg.data[0] = m_aCANrxData[4];
      m_xODF_arg.data[1] = m_aCANrxData[5];
      m_xODF_arg.data[2] = m_aCANrxData[6];
      m_xODF_arg.data[3] = m_aCANrxData[7];

      // write data to the Object dictionary
      abortCode = vCO_SDO_writeOD(len);
      if (abortCode != 0) {
        vCO_SDO_abort(abortCode);
        return 0;
      }
      m_pUser->vSignalDOChanged();     // signal to user task

      // finish the communication
      m_nState = CO_SDO_ST_IDLE;
    }//if((m_aCANrxData[0] & 0x02) != 0)

    // Segmented transfer
    else {
      // verify length if size is indicated
      if ((m_aCANrxData[0] & 0x01) != 0) {
        uint32_t lenRx;
        lenRx = m_aCANrxData[4];
        lenRx += (uint32_t)(m_aCANrxData[5]) << 8;
        lenRx += (uint32_t)(m_aCANrxData[6]) << 16;
        lenRx += (uint32_t)(m_aCANrxData[7]) << 24;
        m_xODF_arg.dataLengthTotal = lenRx;

        // verify length except for domain data type
        if ((lenRx != m_xODF_arg.dataLength) && (m_xODF_arg.ODdataStorage != 0)) {
          vCO_SDO_abort(CO_SDO_AB_TYPE_MISMATCH);   // Length of service parameter does not match
          return 0;
        }
      }//if ((m_aCANrxData[0] & 0x01) != 0)
      m_nBufferOffset = 0;
      m_nSequence = 0;
      m_nState = CO_SDO_ST_DOWNLOAD_SEGMENTED;
    }//else((m_aCANrxData[0] & 0x02) != 0)
    break;

  case CO_SDO_ST_DOWNLOAD_SEGMENTED:
    // verify client command specifier
    if ((m_aCANrxData[0] & 0xE0) != 0x00) {
      vCO_SDO_abort(CO_SDO_AB_CMD);   // Client command specifier not valid or unknown
      return 0;
    }

    // verify toggle bit
    i = (m_aCANrxData[0] & 0x10) ? 1 : 0;
    if (i != m_nSequence) {
      vCO_SDO_abort(CO_SDO_AB_TOGGLE_BIT);   // toggle bit not alternated
      return 0;
    }

    // get size of data in message
    len = 7 - ((m_aCANrxData[0] >> 1) & 0x07);

    // verify length. Domain data type enables length larger than SDO buffer size
    if ((m_nBufferOffset + len) > m_xODF_arg.dataLength) {
      if (m_xODF_arg.ODdataStorage != 0) {
        vCO_SDO_abort(CO_SDO_AB_DATA_LONG);   // Length of service parameter too high
        return 0;
      } else {
        // empty buffer in domain data type
        m_xODF_arg.lastSegment = false;
        abortCode = vCO_SDO_writeOD(m_nBufferOffset);
        if (abortCode != 0) {
          vCO_SDO_abort(abortCode);
          return 0;
        }
        m_xODF_arg.dataLength = CO_SDO_BUFFER_SIZE;
        m_nBufferOffset = 0;
      }
    }

    // copy data to buffer
    for (i = 0; i < len; i++)
      m_xODF_arg.data[m_nBufferOffset++] = m_aCANrxData[i + 1];

    // If no more segments to be downloaded, write data to the Object dictionary
    if ((m_aCANrxData[0] & 0x01) != 0) {
      m_xODF_arg.lastSegment = true;
      abortCode = vCO_SDO_writeOD(m_nBufferOffset);
      if (abortCode != 0) {
        vCO_SDO_abort(abortCode);
        return 0;
      }
      m_pUser->vSignalDOChanged();     // signal to user task

      m_nState = CO_SDO_ST_IDLE;        // finish
    }

    // download segment response and alternate toggle bit
    CO_CanMsg.m_aData[0] = 0x20 | (m_nSequence ? 0x10 : 0x00);
    m_nSequence = (m_nSequence) ? 0 : 1;
    break;

  case CO_SDO_ST_UPLOAD_INITIATE:
    // default response
    CO_CanMsg.m_aData[1] = m_aCANrxData[1];
    CO_CanMsg.m_aData[2] = m_aCANrxData[2];
    CO_CanMsg.m_aData[3] = m_aCANrxData[3];

    // Expedited transfer
    if (m_xODF_arg.dataLength <= 4) {
      for (i = 0; i < m_xODF_arg.dataLength; i++)
        CO_CanMsg.m_aData[4 + i] = m_xODF_arg.data[i];

      CO_CanMsg.m_aData[0] = 0x43U | ((4 - m_xODF_arg.dataLength) << 2);
      m_nState = CO_SDO_ST_IDLE;
    }//if(m_xODF_arg.dataLength <= 4)

    // Segmented transfer
    else {
      m_nBufferOffset = 0;
      m_nSequence = 0U;
      m_nState = CO_SDO_ST_UPLOAD_SEGMENTED;

      // indicate data size, if known
      if (m_xODF_arg.dataLengthTotal != 0) {
        uint32_t len = m_xODF_arg.dataLengthTotal;
        CO_CanMsg.m_aData[4] = (uint8_t)(len & 0xFF);
        CO_CanMsg.m_aData[5] = (uint8_t)((len >> 8) & 0xFF);
        CO_CanMsg.m_aData[6] = (uint8_t)((len >> 16) & 0xFF);
        CO_CanMsg.m_aData[7] = (uint8_t)((len >> 24) & 0xFF);
        CO_CanMsg.m_aData[0] = 0x41;
      } else {
        CO_CanMsg.m_aData[0] = 0x40;
      }
    }//else(m_xODF_arg.dataLength <= 4)
    break;

  case CO_SDO_ST_UPLOAD_SEGMENTED:
    // verify client command specifier
    if ((m_aCANrxData[0] & 0xE0) != 0x60) {
      vCO_SDO_abort(CO_SDO_AB_CMD);   // Client command specifier not valid or unknown
      return 0;
    }

    // verify toggle bit
    i = ((m_aCANrxData[0] & 0x10) != 0) ? 1 : 0;
    if (i != m_nSequence) {
      vCO_SDO_abort(CO_SDO_AB_TOGGLE_BIT);   // toggle bit not alternated
      return 0;
    }

    // calculate length to be sent
    len = m_xODF_arg.dataLength - m_nBufferOffset;
    if (len > 7)
      len = 7;

    // If data type is domain, re-fill the data buffer if neccessary and indicated so
    if ((m_xODF_arg.ODdataStorage == 0) && (len < 7) && (!m_xODF_arg.lastSegment)) {
      // copy previous data to the beginning
      for (i = 0; i < len; i++) {
        m_xODF_arg.data[i] = m_xODF_arg.data[m_nBufferOffset + i];
      }

      // move the beginning of the data buffer
      m_xODF_arg.data += len;
      m_xODF_arg.dataLength = m_pODInterface -> nCO_OD_GetLength(m_nEntryNo, m_xODF_arg.subIndex)
          - len;

      // read next data from Object dictionary function
      abortCode = vCO_SDO_readOD(CO_SDO_BUFFER_SIZE);
      if (abortCode != 0) {
        vCO_SDO_abort(abortCode);
        return 0;
      }

      // return to the original data buffer
      m_xODF_arg.data -= len;
      m_xODF_arg.dataLength += len;
      m_nBufferOffset = 0;

      // re-calculate the length
      len = m_xODF_arg.dataLength;
      if (len > 7)
        len = 7;
    }//if((m_xODF_arg.ODdataStorage == 0) && (len < 7) && (!m_xODF_arg.lastSegment))

    // fill response data bytes
    for (i = 0; i < len; i++)
      CO_CanMsg.m_aData[i + 1] = m_xODF_arg.data[m_nBufferOffset++];

    // first response byte
    CO_CanMsg.m_aData[0] = 0x00 | (m_nSequence ? 0x10 : 0x00) | ((7 - len) << 1);
    m_nSequence = (m_nSequence) ? 0 : 1;

    // verify end of transfer
    if ((m_nBufferOffset == m_xODF_arg.dataLength) && (m_xODF_arg.lastSegment)) {
      CO_CanMsg.m_aData[0] |= 0x01;
      m_nState = CO_SDO_ST_IDLE;
    }

    break;

  default:
    vCO_SDO_abort(CO_SDO_AB_DEVICE_INCOMPAT);     // general internal incompatibility in the device
    return 0;
    break;
  }//switch(state)

  // free buffer and send message
  m_bCANrxNew = false;
  if (m_pCO_Driver -> bCANSend(CO_CanMsg))
    return 0;
  else
    return -1;

}//cCO_SDOtransfer::nSDO_Process ----------------------------------------------

bool cCO_SDOtransfer::vCO_SDO_abort(uint32_t code)   {

  sCANMsg                 CO_CanMsg;

  CO_CanMsg.m_aData[0] = CCS_ABORT;
  CO_CanMsg.m_aData[1] = m_xODF_arg.index & 0xFF;
  CO_CanMsg.m_aData[2] = (m_xODF_arg.index >> 8) & 0xFF;
  CO_CanMsg.m_aData[3] = m_xODF_arg.subIndex;
  CO_CanMsg.m_aData[4] = (uint8_t) (code & 0xFF);
  CO_CanMsg.m_aData[5] = (uint8_t) ((code >> 8) & 0xFF);
  CO_CanMsg.m_aData[6] = (uint8_t) ((code >> 16) & 0xFF);
  CO_CanMsg.m_aData[7] = (uint8_t) ((code >> 24) & 0xFF);
  CO_CanMsg.m_nDLC = 8;
  CO_CanMsg.m_nStdId = OD_SDOServerParameter[0].COB_IDServerToClient + m_nNodeId;

  m_nState = CO_SDO_ST_IDLE;
  m_bCANrxNew = false;
  return(m_pCO_Driver->bCANSend(CO_CanMsg));         // send CAN message

}//cCO_SDOtransfer:: vCO_SDO_abort --------------------------------------------

uint32_t cCO_SDOtransfer::nCO_SDO_InitTransfer(uint16_t index, uint8_t subIndex)    {

  m_xODF_arg.index = index;
  m_xODF_arg.subIndex = subIndex;

  // find object in Object Dictionary
  m_nEntryNo = m_pODInterface -> nCO_OD_Find(index);
  if(m_nEntryNo == 0xFFFF)
    return CO_SDO_AB_NOT_EXIST;         // object does not exist in OD

  // verify existance of subIndex
  if(subIndex > m_pOD[m_nEntryNo].maxSubIndex &&
      m_pOD[m_nEntryNo].pData != NULL)
      return CO_SDO_AB_SUB_UNKNOWN;     // Sub-index does not exist

  // pointer to data in Object dictionary
  m_xODF_arg.ODdataStorage = m_pODInterface -> pCO_OD_GetDataPointer(m_nEntryNo,subIndex);

  // fill ODF_arg
  m_xODF_arg.object = NULL;
  if(m_pODExtensions) {
      CO_OD_extension_t* ext = &m_pODExtensions[m_nEntryNo];
      m_xODF_arg.object = ext->object;
  }
  m_xODF_arg.data = m_aDataBuffer;
  m_xODF_arg.dataLength = m_pODInterface -> nCO_OD_GetLength(m_nEntryNo,subIndex);
  m_xODF_arg.attribute = m_pODInterface -> nCO_OD_GetAttribute(m_nEntryNo,subIndex);

  m_xODF_arg.firstSegment = true;
  m_xODF_arg.lastSegment = true;

  // indicate total data length, if not domain
  m_xODF_arg.dataLengthTotal = (m_xODF_arg.ODdataStorage) ? m_xODF_arg.dataLength : 0;

  m_xODF_arg.offset = 0;

  // verify length
  if(m_xODF_arg.dataLength > CO_SDO_BUFFER_SIZE)    {
      return CO_SDO_AB_DEVICE_INCOMPAT;     // general internal incompatibility in the device
  }

  return 0;
}//cCO_SDOtransfer::nCO_SDO_initTransfer --------------------------------------

uint32_t cCO_SDOtransfer::vCO_SDO_readOD(uint16_t SDOBufferSize) {

  uint8_t* SDObuffer = m_xODF_arg.data;
  uint8_t* ODdata = (uint8_t*) m_xODF_arg.ODdataStorage;
  uint16_t length = m_xODF_arg.dataLength;
  CO_OD_extension_t* ext = 0;

  // is object readable?
  if ((m_xODF_arg.attribute & CO_ODA_READABLE) == 0)
    return CO_SDO_AB_WRITEONLY;     // attempt to read a write-only object

  // find extension
  if (m_pODExtensions != NULL)
    ext = &m_pODExtensions[m_nEntryNo];

  // copy data from OD to SDO buffer if not domain
  if (ODdata != NULL) {
    while (length--)
      *(SDObuffer++) = *(ODdata++);
  }
  // if domain, Object dictionary function MUST exist
  else {
    if (ext->pODFunc == NULL) {
      return CO_SDO_AB_DEVICE_INCOMPAT;     // general internal incompatibility in the device
    }
  }

  // call Object dictionary function if registered
  m_xODF_arg.reading = true;
  if (ext->pODFunc != NULL) {
    uint32_t abortCode = ext->pODFunc(&m_xODF_arg);
    if (abortCode != 0) {
      return abortCode;
    }

    // dataLength (updated by pODFunc) must be inside limits
    if ((m_xODF_arg.dataLength == 0) || (m_xODF_arg.dataLength > SDOBufferSize))
      return CO_SDO_AB_DEVICE_INCOMPAT;     // general internal incompatibility in the device
  }
  m_xODF_arg.offset += m_xODF_arg.dataLength;
  m_xODF_arg.firstSegment = false;

  return 0;
}//cCO_SDOtransfer::vCO_SDO_readOD --------------------------------------------

uint32_t cCO_SDOtransfer::vCO_SDO_writeOD(uint16_t length)  {

  uint8_t* SDObuffer = m_xODF_arg.data;
  uint8_t* ODdata = (uint8_t*) m_xODF_arg.ODdataStorage;

  // is object writeable?
  if ((m_xODF_arg.attribute & CO_ODA_WRITEABLE) == 0) {
    return CO_SDO_AB_READONLY;     // attempt to write a read-only object
  }

  // length of domain data is application specific and not verified
  if (ODdata == 0) {
    m_xODF_arg.dataLength = length;
  }
  // verify length except for domain data type
  else if (m_xODF_arg.dataLength != length) {
    return CO_SDO_AB_TYPE_MISMATCH;     // Length of service parameter does not match
  }

  // call Object dictionary function if registered
  m_xODF_arg.reading = false;
  if (m_pODExtensions != NULL) {
    CO_OD_extension_t* ext = &m_pODExtensions[m_nEntryNo];

    if (ext->pODFunc != NULL) {
      uint32_t abortCode = ext->pODFunc(&m_xODF_arg);
      if (abortCode != 0U) {
        return abortCode;
      }
    }
  }
  m_xODF_arg.offset += m_xODF_arg.dataLength;
  m_xODF_arg.firstSegment = false;

  // copy data from SDO buffer to OD if not domain
  if (ODdata != NULL) {
    while (length--) {
      *(ODdata++) = *(SDObuffer++);
    }
  }

  return 0;
}//cCO_SDOtransfer::vCO_SDO_writeOD -------------------------------------------

CO_ReturnError_t cCO_SDOserver::nConfigure(cCO_NMT_EMCY const * const pCO_NMT_EMCY,
    cUserInterface const * const pUserInterface,
    cCO_OD_Interface const * const pCO_OD_Interface, cCO_Driver const * const pCO_Driver)   {

  if (pCO_NMT_EMCY == NULL)         return CO_ERROR_ILLEGAL_ARGUMENT;
  if (pUserInterface == NULL)       return CO_ERROR_ILLEGAL_ARGUMENT;
  if (pCO_OD_Interface == NULL)     return CO_ERROR_ILLEGAL_ARGUMENT;
  if (pCO_Driver == NULL)     return CO_ERROR_ILLEGAL_ARGUMENT;

  m_pCO_NMT_EMCY = (cCO_NMT_EMCY*)pCO_NMT_EMCY;
  m_pUserInterface = (cUserInterface*)pUserInterface;
  m_pCO_OD_Interface = (cCO_OD_Interface*)pCO_OD_Interface;
  m_pCO_Driver = (cCO_Driver*)pCO_Driver;

  return CO_ERROR_NO;

}//cCO_SDOserver::nConfigure --------------------------------------------------

void cCO_SDOserver::vInit(void)   {

  TaskHandle_t                xHandle;                            // task handle

  vInitPartial();
  if (xTaskCreate( vCO_SDO_Task, ( char * ) CO_SDO_Task_name, 500, NULL, CO_SDO_Task_priority, &xHandle)
      != pdPASS)
    for(;;);
  nAddHandle(xHandle);
  return;
}//cCO_SDOserver::vInit -------------------------------------------------------

/** Exported functions *******************************************************/

void vCO_SDO_Task(void* pvParameters)   {

  // local variables
  CO_NMT_internalState_t      nNMTStateSelf = CO_NMT_INITIALIZING;          // self NMT state
  sCANMsg                     CO_CanMsg;
  uint8_t         i;

  // suspend if SDO not used
  if (((OD_SDOServerParameter[0].COB_IDClientToServer & 0x80000000) != 0)
      || ((OD_SDOServerParameter[0].COB_IDServerToClient & 0x80000000) != 0)) {
    for(;;) vTaskSuspend (NULL);              // RPDO not used, suspend this task
  }

  // SDO object and extensions init
  oSDOtransfer.vCO_SDO_Init(CO_OD, CO_SDO_ODExtensions,
      oCO_SDOserver.m_pCO_OD_Interface, oCO_SDOserver.m_pCO_Driver, oCO_SDOserver.m_pUserInterface);
  for (i = 0; i < CO_OD_NoOfElements; i++) {
    CO_SDO_ODExtensions[i].pODFunc = NULL;
    CO_SDO_ODExtensions[i].object = NULL;
  }

  // Configure Object dictionary extensions
  oSDOtransfer.vCO_OD_Configure(OD_H1200_SDO_SERVER_PARAM, CO_ODF_1200, (void*) &OD_CANNodeID);
  oSDOtransfer.vCO_OD_Configure(OD_H1003_PREDEF_ERR_FIELD, CO_ODF_1003, (void*) &OD_preDefinedErrorField);
  oSDOtransfer.vCO_OD_Configure(OD_H1014_COBID_EMERGENCY, CO_ODF_1014, (void*) &OD_CANNodeID);
  uint8_t nNumElements;
  nNumElements = N_ELEMENTS(OD_RPDOCommunicationParameter);
  for (i = 0; i < (nNumElements > 4 ? 4 : nNumElements); i++)
    oSDOtransfer.vCO_OD_Configure(OD_H1400_RXPDO_1_PARAM + i, CO_ODF_PDOcom, (void*) &OD_CANNodeID);
#ifdef OD_TPDOCommunicationParameter
  nNumElements = N_ELEMENTS(OD_TPDOCommunicationParameter);
  for (i = 0; i < (nNumElements > 4 ? 4 : nNumElements); i++)
    oSDOtransfer.vCO_OD_Configure(OD_H1800_TXPDO_1_PARAM + i, CO_ODF_PDOcom, (void*) &OD_CANNodeID);
#endif
#ifdef OD_storeParameters
  oSDOtransfer.vCO_OD_Configure(OD_H1010_STORE_PARAM_FUNC, CO_ODF_1010, (void*) &OD_storeParameters);
#endif
#ifdef OD_OSCommand
  oSDOtransfer.vCO_OD_Configure(OD_H1023_OS_CMD, CO_ODF_1023, (void*) &OD_OSCommand);
#endif

  // main part
  for (;;) {

    xSemaphoreTake(oCO_SDOserver.m_xBinarySemaphore, portMAX_DELAY);         // try to take semaphore forever
    while (xQueueReceive(oCO_SDOserver.m_xQueueHandle_NMTStateChange,
        &nNMTStateSelf, 0) == pdTRUE);                                       // retreving all state change messages

    if ((nNMTStateSelf != CO_NMT_OPERATIONAL) &&
        (nNMTStateSelf != CO_NMT_PRE_OPERATIONAL))        // not in pre- or operational state ?
      xQueueReset(oCO_SDOserver.m_xQueueHandle_CANReceive);          // delete all SDO messages
    else {
      while (xQueueReceive(oCO_SDOserver.m_xQueueHandle_CANReceive,
          &CO_CanMsg, 0) == pdTRUE) {                                      // try to get new SDO messages

        oSDOtransfer.vSetCANrxData(CO_CanMsg);                                   // write SDO message to SDO internal buffer
        if (oSDOtransfer.nSDO_Process(nNMTStateSelf) == -1) {                    // call SDO processing
          oCO_SDOserver.m_pCO_NMT_EMCY -> bSignalErrorOccured(CO_EM_CAN_TX_OVERFLOW, CO_EMC_CAN_OVERRUN,
              CAN_TX_OVERFLOW_SDO);          // report CAN TX overflow error
        }

      }//while
    }//else
  }//for
}//vCO_SDO_Task ---------------------------------------------------------------
